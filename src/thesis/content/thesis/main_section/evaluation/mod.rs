use crate::thesis::engine::{Block, section_header, paragraph, SubsectionHeaderBlock, subsection_header, ImageBlock, Reference, reference};

pub fn evaluation() -> Block {
    Block::Multiple(vec![
        section_header("Статистичне дослідження ефективності запропонованого методу"),
        paragraph("Статистичне дослідження ефективності запропонованого методу має на меті отримати відповіді на наступні запитання:"),
        Block::UnorderedList(vec![
            "Яким є рівень швидкодії типового програмного забезпечення з різними схемами доступу до оперативної памʼяті при викиорстанні віддаленої \
памʼяті?".into(),
            "Як залежить швидкодія програмного забезпечення що використовує віддалену памʼять від розподілу запитів до обʼєктів у памʼяті?".into(),
            "Яким є рівень швидкодії при використанні різних алгоритмів заміщення проміжків?".into(),
        ]),

        subsection_header("Програмне та апаратне забезпечення, що використовується для дослідження ефективності"),
        paragraph(vec![
            "Для того, щоб оцінити рівень швидкодії для різних типів програмного забезпечення, конфігурацій клієнта віддаленої памʼяті та \
алгоритмів заміщення проміжків, була проведена серія статистичних досліджень. Для цих досліджень було використано два сервери з наступним \
апаратним забезпеченням: процесор ".into(),
            reference("AMD Ryzen 5 3600", Reference::for_website("AMD Ryzen 5 3600 // AMD", "https://www.amd.com/en/product/8456")),
            ", 64 Гб оперативної памʼяті, мережева карта ".into(),
            reference("Intel 82599", Reference::for_website("Intel® 82599ES 10 Gigabit Ethernet Controller", "https://www.intel.com/content/www/us/en/products/sku/41282/intel-82599es-10-gigabit-ethernet-controller/specifications.html")),
            " пропускною здатністю 10 Гбіт/c. \
При цьому, між серверами встановлено пряме мережеве зʼєднання: мережеві карти зʼєднані напряму, без використання додаткового мережевого обладнання, \
таких як маршрутизатори чи комутатори. На цих серверах встановлена операційна система ".into(),
            reference("ArchLinux", Reference::for_website("Arch Linux", "https://archlinux.org/")),
            " з версією ядра 6.5.".into(),
        ]),
        paragraph("Віддалена памʼять бьула інтегрована у три синтетичні інформаційні системи, що були розроблені для цього дослідження."),
        paragraph(vec![
            "Першою такою інформаційною системою є програмне забезпечення для генерації тексту за допомогою великої мовленнєвої моделі ".into(),
            reference("Llama2", Reference::for_website("Llama 2 // Meta AI", "https://ai.meta.com/llama/")),
            ". За основу була взята існуюча реалізація з відкритим кодом цієї програми на мові програмування Rust (".into(),
            reference("llama2.rs", Reference::for_website("gaxler/llama2.rs // GitHub", "https://github.com/gaxler/llama2.rs")),
            "). У віддалену \
памʼять було переміщено ваги нейронної мережі. Ця програма в циклі обробляє запити на \
генерацію наступного токена тексту. Показником швидкодії для цього програмного забезпечення є кількість згенерованих токенів у хвилину. Особливістю \
цієї програми є те, що під час генерації тексту відбувається циклічний доступ до усіх параметрів нейронної мережі у незмінному порядку. Це означає що \
цю програму можно віднести до класу програмного забезпечення, що багато разів сканує весь робочий набір даних у незмінному порядку.".into()
        ]),
        paragraph(vec![
            "Крім цього, було реалізовано інформаційну систему веб сервісу, що обробляє запити від користувача. Ця програма є подібною до тієї, що \
використовувалась для оцінки ефективності у AIFM. Ця програма на початку своєї роботи генерує великий масив зображень, кожне з яких має розмір 8Кб. Крім \
цього, генерується набір користувачів, кожному з яких ставиться у відповідність одне з зображень. Обидві структури даних (масив та хеш-таблиця) \
зберігаються у віддаленій памʼяті. Під час своєї роботи, ця інформаційна система обробляє запити, кожен з яких складається з 32 випадкових ідентифікаторів \
користувачів. За кожним ідентифікатором користувача, веб сервіс отримує ідентифікатор зображення з хеш-таблиці. Серед усіх ідентифікаторів зображень у \
запиті обирається випадковий ідентифікатор, по якому отримається зображення з масиву зображень. Після цього, отримане зображення шифрується за допомогою ".into(),
            reference("AES GCM", Reference::for_website("Galois/Counter Mode // Wikipedia", "https://en.wikipedia.org/wiki/Galois/Counter_Mode")),
            ", стискається алгоритмом Snappy, після чого результат надсилається у відповідь на запит. Слід зазначити, що розподіл ідентифікаторів \
користувачів, а також відповідність зображень користувачам слідують ".into(),
            reference("розподіленню Ципфа", Reference::for_website("Zipf's law", "https://en.wikipedia.org/wiki/Zipf%27s_law")),
            " з параметром s (за замовчуванням дорівнює 0.8). Показником \
швидкодії для цієї програми є кількість запитів що в середньому оброблено за секунду. Ця інформаційна система є прикладом програми з класу \
програмного забезпечення, що використовує сховище типу ключ-значення для зберігання даних запити до якого відбуваються з деяким нерівномірним \
розподілом.".into(),
        ]),
        paragraph(vec![
            "Іншою інформаційною системою у яку було інтегровано віддалену памʼять є застосунок, що обробляє запити до таблиці (dataframe) з даними подібно \
до типової системи аналізу даних чи бази даних. На початку своєї роботи, ця програма завантажує у памʼять ".into(),
            reference("набір даних з рейсами літаків взятий з Kaggle", Reference::for_website("Flight Status Prediction - Kaggle".to_owned(), "https://www.kaggle.com/datasets/robikscube/flight-delay-dataset-20182022".to_owned())),
            ". Набор даних з 61 колонки розміщується у структурі даних вектор адаптованої для роботи з віддаленою памʼяттю. Ця інформаційна система обробляє запити \
згенеровані випадковим чином для фільтрації по даті, аеропорту та авіакомпанії. Для кожного запиту з набору даних обираються 10000 рейсів що \
відповідають критеріям та рахується середня звтримка прибуття літака у аеропорт призначення. Значення затримки повертається як відповідь на запит. \
Ця інформаційна система належить до класу програм що використовує структури даних адаптовані для роботи з віддаленою памʼяттю, обробляє дані у потоковому \
режимі та може обробляти дані (у цьому випадку - рядки) в будь-якому порядку.".into(),
        ]),

        subsection_header("Пропускна здатність різних класів програмного забезпечення"),
        paragraph("Для усіх трьох інформаційних систем що розглядаються було проведено вимірювання пропускної здатності в залежності від частки локальної \
памʼяті. Іншими словами, розмір набору даних, з яким працює програмне забезпечення є однаковим для усіх запусків програми одного типу, але розмір \
простору відведений для зберігання даних у локальній памʼяті обмежується певним процентом від розміру набору даних, інша частина зберігається у \
памʼяті віддалених вузлів. Значення пропускної здатності нормалізуються максимальною пропускною здатністю отриманою для типу програмного забезпечення \
з усіх проведених вимірювань."),
        paragraph("Результати вимірювання пропускної здатності наведено на графіку нижче."),

        Block::Image(ImageBlock::new(
            "./images/plot_demo_throughput.png".to_owned(),
            "Пропускна здатність програмного забезпечення в залежності від його типу та обсягу локальної памʼяті".to_owned()
        ).with_scaling(0.5)),
        paragraph("З цього графіку помітно, що зі зменшенням частки локальної памʼяті зменшується пропускна здатність програмного забезпечення. \
При цьому, інформаційна система що обробляє запити до таблиці (dataframe) з усіх програм що розглядалися мала найменше зниження швидкодії. Це пояснюється \
використанням структур даних адаптованих для роботи з віддаленою памʼяттю, що дозволило знизити кількість переміщень проміжків між локальною памʼяттю \
та памʼяттю віддалених вузлів."),
        paragraph("Порівняння рівня швидкодії для програми що генерує текст та веб сервісу приводить до висновку що віддалена памʼять є більш ефективною \
для програмного забезпечення що працює з великими обʼєктами та незмінними схемами доступу до памʼяті."),
        paragraph("Зі зниженням частки локальної памʼяті рівень швидкодії програмного забезпечення наближується до 15% \
від максимального."),

        subsection_header("Вплив розподілу запитів на пропускну здатність"),
        paragraph("Для вимірювання впливу розподілу запитів на пропускну здатність, було зібрано статистику пропускної здатності інформаційної системи \
веб сервісу з 80% локальної памʼяті та різним значенням параметру s розподіла Ципфа для розподілу ідентифікаторів користувачів у запитах та збережених \
ідентифікаторів зображень. При s = 0 розподіл є рівномірним, при s = 1 всі запити мають однакові ідентифікатори."),
        paragraph("Результати вимірювання пропускної здатності при різних значеннях параметру розподілу наведено на графіку нижче."),

        Block::Image(ImageBlock::new(
            "./images/plot_throughput_distribution.png".to_owned(),
            "Пропускна здатність веб сервісу в залежності від розподілу запитів".to_owned(),
        ).with_scaling(0.4)),
        paragraph("З результатів цього дослідження можна зробити висновок що чим більш рівномірним є розподіл запитів до даних у віддаленій памʼяті, тим \
більшим є негативний ефект на швидкодію програмного забезпечення."),
        paragraph("На практиці, типове сховище типу ключ-значення має розподіл запитів що є близьким до розподілу Ципфа з параметром s = 0.88. Для такого \
програмного забезпечення при частці локальної памʼяті рівної 80% від загального обсягу памʼяті, пропускна здатність згідно з графіком дорівнює 63% від \
звичайного рівня."),

        subsection_header("Порівняння ефективності алгоритмів заміщення проміжків"),
        paragraph("Для порівняння ефективності різних алгоритмів заміщення проміжків було використано програмне забезпечення для генерації тексту з часткою \
локальної памʼяті рівної 80% від усієї памʼяті що використовується для зберігання вагів нейронної мережі."),
        paragraph("Були порівняні наступні алгоритми заміщення проміжків:"),
        Block::UnorderedList(vec![
            "заміщення проміжків випадковим чином (random), тобто у разі необхідності переміщення проміжків з локальної паʼмяті у памʼять віддалених вузлів проміжки \
обираються випадковим чином зі списку проміжків що знаходяться у локальній памʼяті. Цей алгоритм є зручним для визначення базового рівня, з яким можна \
порівнювати інші алгоритми заміщення проміжків.".to_owned(),
            "заміщення найменш нещодавно використаних проміжків (least recently used), тобто при переміщенні проміжків з локальною памʼяті у памʼять \
віддалених вузлів обираються ті проміжки доступ до яких не виконувавася найбільший інтервал часу. Цей алгоритм часто використовується для заміщення сторінок \
у операційних системах, у системах кешування та інших схожих задачах. Але програмне забзепечення що розглядається в цьому випадку є гарним прикладом \
програмного забезпечення з схемами доступу до памʼяті для яких використання LRU є неефктивним. Оскільки доступ до вагів кожного шару нейронної мережі \
є незмінним і повторюється в циклі, то найменш нещодавно використаним проміжком буде той, доступ до якого відбудеться одним з наступних.".to_owned(),
            "заміщення проміжків з використанням \"оптимальної моделі\" (алгоритм Беладі) - для переміщення з локальної памʼяті у віддалену обираються \
ті проміжки, доступ до яких не буде потрібен довше всього (базуючись на попередньо зібраній статистиці про роботу програмного забезпечення). Оскільки \
ефективна робота цього алгоритму заміщення проміжків залежить від зібраної статистики, то перед виконанням вимірювання програмне забезпечення було \
запущено один раз для збору статистики (без цього кроку, перше вимірювання буде нижчим за дійсний показник швидкодії та не буде коректним).".to_owned(),
        ]),
        paragraph("Результати вимірювання пропускної здатності інформаційної системи що розглядається з різними алгоритмами заміщення проміжків \
наведено на графіку нижче."),

        Block::Image(ImageBlock::new(
            "./images/plot_replacement_policies.png".to_owned(),
            "Пропускна здатність програмного забезпечення для генерації тексту в залежності від алгоритму заміщення проміжків що використовується".to_owned(),
        ).with_scaling(0.7)),
        paragraph("З графіку видно, що для цього типу програмного забезпечення алгоритм LRU є неефктивним та призводить до низького рівня швидкодії при \
будь-якому рівні локальної памʼяті."),
        paragraph("Алгоритм заміщення проміжків що адаптує параметри моделі за зібраною статистикою є найбільш ефективним для цієї інформаційної системи. \
При 40% локальної памʼяті цей алгоритм дозволяє досягти на 53% більшу пропускну здатність у порівнянні з LRU."),
        paragraph("Однак, слід зазначити що програмне забезпечення що розглядається є кращим випадком: це програмне забезпечення має незмінну схему \
доступу до памʼяті для якої можна використати \"оптимальну модель\" та через особливості роботи з памʼяттю алгоритм LRU який часто використовується \
для заміщення сторінок не є ефективним."),

        subsection_header("Зміни у програмний код при інтеграції віддаленої памʼяті"),
        paragraph("Оскільки при інтеграції віддаленої памʼяті у програмне забезпечення що генерує текст за допомогою великої мовленнєвої моделі за основу \
було взято програмний код вже існуючого програмного забезпечення, це дає можливість оцінити кількість необхідних змін у код програмного забезпечення для \
інтеграції у нього віддаленої памʼяті."),
        paragraph("В цьому випадку, для інтеграції віддаленої памʼяті було потрібно додати клієнтську бібліотеку у список залежностей та ініціалізувати клієнт \
вказавши адресу вузла керування (один рядок коду). Для переміщення вагів нейронної мережі у віддалену памʼять знадобилося додати у список аргументів функції \
завантаження вагів клієнт віддаленої памʼяті. Крім цього, було необхідно змінити тип змінних (з Vec<T> на FarMemoryVec<T>) в усіх структурах даних та функціях \
що працюють з цими даними."),
        paragraph("Приклад змін що було виконано наведено на наступних рисунках."),

        Block::Image(ImageBlock::new(
            "./images/code_changes_data_structures.png".to_owned(),
            "Зміни у визначення структур даних для використання віддаленої памʼяті".to_owned()
        ).with_scaling(0.4)),

        Block::Image(ImageBlock::new(
            "./images/code_changes_signatures.png".to_owned(),
            "Зміни у визначення функцій для використання клієнту віддаленої памʼяті".to_owned(),
        ).with_scaling(0.4)),

        paragraph("Така кількість необхідних змін у програмний код є допустимою, оскільки у типовому програмному забезпеченні інформаційної системи лише \
невелика частина структур даних мають великий розмір. Саме такі структури можна розглядати для перенесення у віддалену памʼять, перенесення усіх даних що \
використовується програмним забезпеченням не є виправданим."),

        Block::SubsectionHeader(SubsectionHeaderBlock::without_numbering("Висновки до розділу".to_owned())),
        paragraph("В даному розділі було проведено статистичне дослідження ефективності запропонованого методу надання віддаленої памʼяті у розподілених \
системах."),
        paragraph("Було проведено вимірювання пропускної здатності програмного забезпечення з різними схемами доступу до памʼяті при різних рівнях \
локальної памʼяті. Було встановлено що запропонований метод надання віддаленої памʼяті є найбільш ефективним для програмного забепечення що \
використовує високорівневі структури даних що адаптовані для використання з віддаленою памʼяттю, для програмного забезпечення що працює з великими \
обʼєктами, має незмінні схеми доступу до памʼяті. Крім цього, віддалена памʼять є більш ефективною для програмного забезпечення що має зміщенний \
розподіл запитів, тобто такий де невелика частина обʼєктів отримає значно більше запитів за інші обʼєкти."),
        paragraph("Було порівняно різні алгоритми заміщення проміжків та встановлено що для розглянутого програмного забезпечення алгоритм заміни \
проміжків що використовує статистику доступу до памʼяті є більш ефективним за прості еврістики."),
        paragraph("Віддалену памʼять було інтегровано у існуюче програмне забезпечення. Це дозволило перевірити що для інтеграції віддаленої памʼяті \
у програмне забезпечення потрібні лише незначні зміни у програмний код."),
    ])
}
