use {
    crate::thesis::engine::{Block, subsection_header, paragraph, SubsectionHeaderBlock, TextSpan, ImageBlock, section_header},
    super::super::applications::{DEPLOYMENT_DIAGRAM, COMPONENT_DIAGRAM, CLASS_DIAGRAM, ACCESS_SEQUENCE, BACKGROUND_THREAD_SEQUENCE},
};

mod requirements;
mod tools;

pub fn software() -> Block {
    Block::Multiple(vec![
        section_header("Опис програмного забезпечення"),

        requirements::requirements(),
        tools::tools(),

        subsection_header("Архітектура програмного забезпечення"),
        subsection_header(SubsectionHeaderBlock::new("Компоненти програмного забезпечення що надає віддалену памʼять".to_owned()).with_level(2)),
        paragraph("Як було зазначено раніше, цей метод надання віддаленої памʼяті використовує три компоненти: інтеграція у програмне забезпечення на \
стороні вузлів обчислення, вузли зберігання та вузол керування. "),
        paragraph(TextSpan::Multiple(vec![
            "Схема структурна розгортання цих компонентів наведена у додатку ".into(),
            TextSpan::ApplicationReference(DEPLOYMENT_DIAGRAM),
            ".".into(),
        ])),
        paragraph("Інтеграція у програмне забезпечення представлена клієнтською бібліотекою або віртуальним блоковим пристроєм. Інтеграція налаштовується \
розробником інформаційної системи яка використовує віддалену памʼять. У разі використання бібліотеки, цей компонент розгортається у кількості екземплярів \
рівній кількості екземплярів програмного забезпечення інформаційної системи. При використанні блокового пристрою - в залежності від кількості серверів \
на яких розміщена інформаційна система та кількості блокових пристроїв на кожному з них. Очікується що під час роботи інформаційної системи кількість \
вузлів обчислень може змінюватись."),
        paragraph("Вузол керування та вузли зберігання розгортаються на інших серверах. Вузол керування завжди один, а кількість вузлів зберігання \
може змінюватись адміністратором інформаційної системи або планувальником задач, що використовується, в залежності від обсягу вільних ресурсів. На \
одному сервері може одночасно бути розгорнуто декілька вузлів зберігання."),

        subsection_header(SubsectionHeaderBlock::new("Взаємодія компонентів".to_owned()).with_level(2)),
        paragraph(TextSpan::Multiple(vec![
            "Схема структурна компонентів програмного забезпечення що надає віддалену памʼять наведено у додатку ".into(),
            TextSpan::ApplicationReference(COMPONENT_DIAGRAM),
            ". Ця схема окрім компонентів також показує звʼязки між ними, а саме:".into(),
        ])),
        Block::UnorderedList(vec![
            "вузли зберігання передають на вузол керування інформацію про кількість вільної памʼяті".to_owned(),
            "вузол керування передає вузлам обчислення призначені їм вузли зберігання та кількість доступної памʼяті на них".to_owned(),
            "вузли зберігання та обчислення передають інформацію про свій стан через регулярні інтервали часу та вузол керування".to_owned(),
            "вузли обчислення передають проміжки памʼяті на зберігання вузлам обчислення та за запитом отримують ці дані назад".to_owned(),
        ]),
        paragraph("Передача даних між вузлами виконується по протоколу TCP."),

        subsection_header(SubsectionHeaderBlock::new("Структура клієнта віддаленої памʼяті".to_owned()).with_level(2)),
        paragraph(TextSpan::Multiple(vec![
            "Структура бібліотеки клієнта віддаленої памʼяті представлена у вигляді діаграми класів у додатку ".into(),
            TextSpan::ApplicationReference(CLASS_DIAGRAM),
            ". На діаграмі представлені:".into(),
        ])),
        Block::UnorderedList(vec![
            "клієнт віддаленої памʼяті (FarMemoryClient), з яким взаємодіє інформаційна система".to_owned(),
            "проміжки памʼяті (FarMemorySpan) та набори байтів що вони використовують (FarMemoryData)".to_owned(),
            "бекенд зберігання на вузлі зберігання (NetworkNodeBackend)".to_owned(),
            "бекенд зберігання на SSD диску (LocalDiskBackend)".to_owned(),
            "бекенд зберігання у локальній памʼяті (InMemoryBackend)".to_owned(),
            "кодування стиранням (ErasureCodingBackend)".to_owned(),
            "реплікація (ReplicationBackend)".to_owned(),
            "стиснення даних (CompressionBackend)".to_owned(),
            "шифрування даних (EncryptionBackend)".to_owned(),
            "розумні покажчики FarMemory<T> і FarMemoryLocal<T> для зберігання обʼєктів".to_owned(),
            "розумні покажчики FarMemorySerialized<T> і FarMemorySerializedLocal<T> для зберігання обʼєктів з використанням серіалізації".to_owned(),
            "буфер байтів (FarMemoryBuffer)".to_owned(),
            "реалізації структури даних вектор, адаптованих для роботи з віддаленою памʼяттю (FarMemoryVec<T>, FarMemoryBufferedVec<T>, FarMemorySerializedVec<T>)".to_owned(),
            "реалізація структури даних хеш-таблиця, адаптована для роботи з віддаленою памʼяттю (FarMemoryHashMap)".to_owned(),
            "реалізація алгоритмів заміщення проміжків: RandomReplacementPolicy, LeastRecentlyUsedreplacementPolicy, MostRecentlyUsedReplacementPolicy, ReplayReplacementPolicy".to_owned()
        ]),
        // can also add class diagram for far memory manager and storage later if I will need more pages.

        subsection_header(SubsectionHeaderBlock::new("Послідовність доступу до даних у віддаленій памʼяті".to_owned()).with_level(2)),
        paragraph(TextSpan::Multiple(vec![
            "Схема структурна послідовності доступу до обʼєкту що зберігається у віддаленій памʼяті інформаційною системою представлена у додатку ".into(),
            TextSpan::ApplicationReference(ACCESS_SEQUENCE),
            ". На схемі показано випадок коли обʼєкт зберігається за допомогою FarMemory<T>, знаходиться у віддаленій памʼяті та при доступі до нього \
виникає потреба у звільненні додаткової локальної памʼяті.".into(),
        ])),

        subsection_header(SubsectionHeaderBlock::new("Послідовність роботи фонового потоку клієнта віддаленої памʼяті".to_owned()).with_level(2)),
        paragraph(TextSpan::Multiple(vec![
            "Схема структурна послідовності роботи фонового потоку переміщення проміжків представлена у додатку ".into(),
            TextSpan::ApplicationReference(BACKGROUND_THREAD_SEQUENCE),
            ". На схемі показано випадок коли фоновий потік звільняє локальну памʼять через переміщення проміжків у віддалену памʼять, а після цього - \
переміщує проміжок у локальну памʼять для зменшення блокування основного потоку виконання. Проміжки обираються через використання алгоритму заміщення \
що спирається на статистику доступів до памʼяті що була зібрана під час роботи програмного забезпечення.".into(),
        ])),

        // - специфікація функцій (only add if I need some more pages, lol).

        subsection_header("Інструкція користувача"),
        paragraph("Користувачем програмного забезпечення що надає віддалену памʼять є розробник інформаційної системи у яку віддалена памʼять інтегрується. \
Рекомендованим методом інтеграції віддаленої памʼяті у програмне забезпечення є використання клієнтської бібліотеки. Саме цей спосіб розглядається далі \
в цій інструкції."),
        paragraph("Першим кроком є розгортання вузла керування. Для цього, користувач повинен на сервері де буде розгорнуто цей компонент виконати команду \
git clone https://github.com/nikitavbv/far-memory.git для завантаження вихідного коду програмного забезпечення для надання віддаленої памʼяті після чого ʼ
наступні дії виконуються у папці far-memory. Користувач повинен самостійно створити токен \
(будь-яка послідовність символів, використовується як пароль) та зберегти у файл config/.token . Після цього, вузол керування запускається командою \
cargo run --release -- --manager. Після цього, вузол керування є готовим для роботи з іншими компонентами системи."),
        paragraph("Наступним кроком є розгортання вузлів зберігання. На кожному з серверів, де розгортаються вузли зберігання користувач повинен виконати \
дії що описані далі. Так само як і для вузла керування, вихідний код завантажується командою git clone https://github.com/nikitavbv/far-memory.git . Токен \
що було використано під час налаштування вузла керування, потрібно так само зберегти (використати існуючий токен, не створювати нові) у файл config/.token . \
Вузол зберігання після цього запускається командою cargo run --release -- --storage --manager-endpoint 'MANAGER_ENDPOINT' --endpoint 'LOCAL_ENDPOINT', де \
MANAGER_ENDPOINT - адреса та порт (наприклад: 192.168.254.30:14000) на якому працює вузол керування, а LOCAL_ENDPOINT - це адреса та порт вузла зберігання \
що розгортається. Адреса що вказується для вузла зберігання повинна бути доступною для зʼєднання з інших вузлів. Після виконання цієї команди, вузол \
зберігання є готовим до роботи."),
        paragraph("Інтеграція клієнтської бібліотеки у програмний код інформаційної системи що написано на мові програмування Rust відбувається шляхом \
додавання бібліотеки у список залежностей. Для цього в Cargo.toml потрібно додати рядок far-memory = { git = \"https://github.com/nikitavbv/far-memory.git\" }. \
Після цього, клієнт віддаленої памʼяті створюється викликом FarMemoryClient::new (приклад наведено на рисунку 3.1)."),

        Block::Image(ImageBlock::new("./images/client_init.png".to_owned(), "Ініціалізація клієнта віддаленої пам'яті".to_owned())),

        paragraph("Після цьго клієнт віддаленої памʼяті використовується програмним забезпеченням для зберігання даних у цьому класі памʼяті та \
автоматичного переміщення даних між локальною та віддаленою памʼяттю. Наприклад, для переміщення обʼєкта у віддалену памʼять, розробник може використати \
функцію FarMemoryClient::object<T>, яка повертає розумний покажчик з яким можна взаємодіяти так само як і з самим обʼєктом, без внесення значних змін \
у вихідний код програмного забезпечення (приклад наведено на рисунку 3.2)."),

        Block::Image(ImageBlock::new("./images/client_object.png".to_owned(), "Використання об'єктів у віддаленій памʼяті".to_owned())),

        paragraph("Використання структур даних адаптованих для роботи з віддаленою памʼяттю відбувається схожим чином. Наприклад, для переміщення списку \
з елементів у віддалену памʼять з використанням серіалізації (FarMemorySerializedObjectVec<T>), розробник повинен використати функцію \
FarMemoryClient::serialized_object_vec<T>, яка повертає розумний покажчик на структуру даних типу вектор адаптовану для роботи з віддаленою памʼяттю (\
приклад наведено на рисунку 3.3)."),
        Block::Image(ImageBlock::new(
            "./images/client_serialized_object_vec.png".to_owned(),
            "Використання структури даних адаптованої для роботи з віддаленою пам'яттю".to_owned()
        )),
        // I can also add more notes about other functions.
        // I can also describe how virtual block device works.

        Block::SubsectionHeader(SubsectionHeaderBlock::without_numbering("Висновки до розділу".to_owned())),
        paragraph("В даному розділі було розглянуто реалізацію програмного продукту що надає віддалену памʼять у розподіленій системі."),
        paragraph("Описано вимоги до програмного продукту що розглядається. До цих вимог входять набір фунціоналу, що є необхідним для використання клієнту \
віддаленої памʼяті у типовому програмному забезпеченні інформаційної системи. Крім цього, описані вимоги до апаратного забезпечення."),
        paragraph("Розглянуто використання мови програмування Rust як найбільш ефективної для цієї задачі та визначено набір бібліотек що використовуються."),
        paragraph("Описано компоненти з яких складається програмний продукт, звʼязки між ними. Розглянуто компоненти клієнтської бібліотеки віддаленої памʼяті. \
Наведено діаграми послідовностей її роботи під час взаємодії з даними що знаходяться у віддаленій памʼяті."),
        paragraph("Було наведено інструкцію з розгортання віддаленої памʼяті та її інтеграцію у програмне забезпечення інформаційної системи."),
    ])
}
