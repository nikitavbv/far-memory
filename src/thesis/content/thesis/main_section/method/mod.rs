use crate::thesis::engine::{Block, section_header, subsection_header, paragraph, unordered_list, SubsectionHeaderBlock, ImageBlock};

pub fn far_memory_method() -> Block {
    Block::Multiple(vec![
        section_header("Методи та засоби надання віддаленої памʼяті"),
        paragraph("Загалом, принцип роботи віддаленої памʼяті полягає в тому, що програмне забезпечення передає у віддалену памʼять дані для зберігання, а коли до цих даних потрібен доступ, то \
реалізація віддаленої памʼяті за запитом від застосунку переміщує дані з інших більш повільних пристроїв зберігання даних у локальну оперативну памʼять. Після переміщення, програмне \
забезпечення працює з даними так само, як і з будь-якими іншими даними у оперативній памʼяті. Після того, як робота з даними закінчена, вони знов переміщуються на зберігання у інший клас памʼяті. \
Саме це надає можливість зменшити використання оперативної памʼяті вузла та обробляти більше даних ніж обʼєм памʼяті прозоро для програмного забезпечення (тобто без значних змін у код, та те, як \
застосунок працює з даними)."),

        subsection_header("Компоненти системи"),
        paragraph("Перший компонент, з якого варто почати розглядати систему це вузли обчислення (compute nodes). Ці вузли є програмним забезпеченням, у яке інтегрується віддалена памʼять. Слід \
зазначити, що вузли розглядаються не з точки зору фізичного обчислювального вузла, а як екземпляр програмного забезпечення, що виконується. Користуватися віддаленою памʼяттю може одночасно різне \
програмне забезпечення, різна кількість його екземплярів, різні версії з різними налаштуваннями. При цьому, як і у звичайному програмному забезпеченні, що працює з локальною оперативною памʼяттю, \
програма що зберігає дані у віддаленій памʼяті не має доступу до даних інших програм."),
        paragraph("Вузел обчислення складається з програмного забезпечення у яке інтегрована віддалена памʼять та клієнта віддаленої памʼяті. Програмне забезпечення працює з клієнтом віддаленої \
памʼяті для розміщення даних у ній та для отримання доступу до цих даних. Крім цього, про властивості програмного забезпечення у яке інтегрується віддалена памʼять не робиться додаткових припущень."),
        paragraph("Основною сутністю, з якою працює клієнт віддаленої памʼяті, є проміжок памʼяті (span). Проміжок памʼяті можна вважати аналогічним сторінці памʼяті у операційній системі, тобто це \
безперервним блоком памʼяті. Проміжок памʼяті має ідентифікатор (64-бітне число), яке ключем у будь-яких операціях повʼязаних з проміжком. Памʼять, яка повʼязана з проміжком, має фіксовану довжину, \
тобто не змінюється після створення проміжку, але одночасно можуть існувати проміжки різної довжини. Дані (послідовність байтів) можуть знаходитись на різних пристроях зберігання, проте вони \
залишаються привʼязаними до цього проміжку."),
        paragraph("Для зберігання даних за межами оперативної памʼяті, клієнт віддаленої памʼяті використовує задану користувачем конфігурацію бекенду (backend). В цій роботі розглядаються різні \
реалізації бекенду, такі як локальна памʼять, SSD диски, памʼять одного чи декількох віддалених вузлів, але головна увага приділяється зберіганню даних у памʼяті багатьох віддалених вузлів. \
Саме переміщення даних у памʼять багатьох віддалених вузлів надає цій розробці практичної цінності."),
        paragraph("Тому вузли зберігання даних (storage nodes) є іншим компонентом системи. Як бекенд віддаленої памʼяті, цей вузел можна розглядати як сховище у форматі ключ-значення, де ключем \
є ідентифікатор проміжку памʼяті, а значенням - дані, що зберігаються у цьому проміжку. Вузли зберігання даних обробляють запити на запис та читання проміжків (при цьому читання видаляє дані, \
так як немає сенсу одночасно зберігати одні й ті самі дані як на вузлах зберігання, так і на вузлах обчислення). Таке формулювання призначення цих вузлів може зробити привабливим використання \
сховищ даних які працюють за схожим принципом, таких як наприклад Redis. Однак, використання такого сховища даних наклало б обмеження на можливості оптимізації протоколу, необхідних для \
мінімізації затримки з урахуванням особливостей задачі, що вирішується."),
        paragraph("Наявність багатьох вузлів зберігання та обчислення створює необхідність у компоненті, який керував би роботою кластеру - вузла керування (manager node). Цей компонент \
повинен вирішувати декілька задач. По-перше, за запитом від вузлів обчислення надавати доступ до вузлів зберігання згідно з кількістю памʼяті необхідної для програмного забезпечення. \
Для цього, вузел керування відслідковує рівень завантаженності вузлів у кластері, та пріоритизує ті вузли, де найбільше вільної памʼяті. Крім цього, вузел керування відслідковує стан інших \
компонентів та обробляє випадки виходу з ладу інших вузлів, так і їх запланованого виводу на обслуговування. Також цей компонент надає інструменти для моніторингу стану віддаленої памʼяті. \
У випадку використання локальної памʼяті (як наприклад SSD диску) чи лише одного віддаленого вузла зберігання наявність вузла керування не є необхідним."),
        paragraph("Вузел керування також збирає статистику про роботу системи та визначає параметри її роботи (наприклад, умови за яких проміжки памʼяті переміщуються між локальною та \
віддаленою памʼяттю). Ці обчислення відбуваються на цьому вузлі через наявність більшої інформації про роботу системі ніж та, що є доступною на окремих вузлах. Також, централізоване \
керування параметрами роботи віддаленої памʼяті спрощує її використання для користувачів (розробників програмного забезпечення, у яке вона інтегрується) - це дозволяє уникинути проблеми \
задавати параметри на кожному вузлі окремо. В архітектурі системи, що була обрана, компоненти віддаленої памʼяті отримують параметри роботи від вузла керування під час роботи системи. \
Початкові параметри задаються в момент ініціалізації віддаленої памʼяті та можуть змінюватись під час її роботи. Зміна параметрів під час роботи є необхідною, так як поведінка та закономірності \
роботи з памʼяттю програмного забезпечення як правило змінюються у часі і система повинна адаптувати параметри з урахуванням нової інформації."),
        paragraph("Кожен з цих компонентів надається користувачу як виконуваний файл для операційної системи Linux (за винятком клієнту віддаленої памʼяті який може інтегруватися у вузел \
обчислення за допомогою бібліотеки або окремого сервісу, що взаємодіє з механізмами керування памʼяттю операційної системи). Також надаються Docker контейнери та конфігурація Kubernetes, \
що спрощує розгортання у кластері. До середовища, в якому розгортається система, ставиться вимога що всі вузли доступні всім іншим вузлам за мережею."),
        paragraph("При використанні реалізації відалленої памʼяті на практиці виникає потреба у інтеграції з зовнішними системами моніторингу для того, щоб одночасно контролювати як роботу \
віддаленої памʼяті, так і програмного забезпечення у яке вона інтегрована. Для цього, у кожному з компонентів віддаленої памʼяті передбачено відправку метрик у окремому потоці через регулярні\
проміжки часу у Prometheus або інші сховища метрик сумісні з ним. Для відправки метрик використовується push-механізм, так як це робить комунікацію з зовнішньою системою моніторингу більш \
простою, прибираючи необхідність у використанні механізму Service Discovery."),
        paragraph("Так як вузли обчислення підключаються одночасно до декількох вузлів зберігання та до вузла керування, то виникає потреба в можливості ідентифікації сесії роботи з віддаленою \
памʼяттю. Це також потрібно для того, щоб у разі закриття та повторного відкриття зʼєднання сервер міг встановити що клієнт є тим самим екземпляром програмного забезпечення. Для вирішення \
цієї проблеми, у протокол передачі інформації між вузлами додається ідентифікатор сесії (run id), котрий генерується на вузлі обчислення під час запуску програми та ініціалізації клієнту \
віддаленої памʼяті і залишається незмінним увесь час роботи програми."),
        paragraph("Крім цього, вузел обчислення при встановленні зʼєднання з вузлом кеурвання крім run id також передає таку інформацію як тип та версія програмного забезпечення. Це потрібно \
для моніторингу та збору статистики для автоматичної оптимізації параметрів віддаленої памʼяті."),
        // can tell something about the expectations (робляться наступні припущення щодо середовища):
        /* unordered_list(vec![
            "Вважається, що усі вузли системи розміщені у межах одного центру обробки даних та мають низькі мережеві затримки при спілкуванні між собою".to_owned(),
            "Мережа працює стабільно і між будь-якими двома вузлами в кластері є можливість встановити зʼєднання. Оскільки в багатьох інших задачах існує таке саме припущення (наприклад, у розподілених базах даних) і враховуючи той факт, що у межах одного центру обробки даних мережа зазвичай достатньо стабільна, то використання цього припущення не повинно накладати значних обмежень на середовища, в яких це програмне рішення може використатися".to_owned(),
            "Будь-яка розгорнута клієнтська інтеграція має можливість підключитися до сервісу керування кластером за призначеною йому IP адресою в мережі та номером порту".to_owned(),
            "Будь-яка розгорнута клієнтська інтеграція, а також сервіс керування кластером мають можливість підключитись до будь-якого розгорнутого сервісу зберігання блоків за призначеними їм IP адресами в мережі та номером порту".to_owned(),
            "Будь-який розгорнутий сервіс зберігання блоків даних має можливість відкрити зʼєднання з сервісом керування кластером за призначеною йому IP адресою в мережі та номером порту".to_owned(),
            "Для налаштування та додавання у кластер нової клієнтської інтеграції чи сервісу зберігання даних користувачу достатньо вказати IP адресу та порт сервісу керування кластером".to_owned(),
        ]),*/
        // finally, tell about async pipeline to collect events.
        // tell that manager node allows to control things a bit (for example, schedule maintenance).
        // explain how components communicate, why bincode should be used.
        // explain which methods and required to and which are optional to implement in backends.
        // explain how multiple clients work with the same storage.
        // explain how prepend works.

        subsection_header("Інтеграція у програмне забезпечення"),
        // tell how library and service running on the end node would be working more specifically. Tell how spans are swapped in and out here. Tell about remotable pointers, buffers, optimized data structures and streaming.
        // tell about ref-counting and identification which spans are not in use. explain how memory limits work. explain how user is supposed to use the swap file and what is done to prevent recursive swap (idk if that is
        // right name for that). tell about traces as a way to monitor the system (if that is a good topic to explain).
        // explained objects serialization.
        // explain why NBD is used for running on the end node. tell that options are a library or a service running on the end node.
        // Tell how span size is being chosen and what effect it has.

        subsection_header("Забезпечення відмовостійкості"),
        // tell about replication to remote nodes and local SSDs and erasure coding. Tell how exactly data will be restored and deleted. Explain that failure domain becomes larger when far memory is used.
        // tell about healthchecks.

        subsection_header("Забезпечення швидкодії віддаленої памʼяті"),
        // tell about optimizing network requests (why TCP (also, why nodelay is used and duplex) is used and not UDP, or http or some kind of existing RPC implementation).
        // tell about reasoning behind partial swap in/swap out. tell why compression is not used. tell why copies should be avoided. tell a bit about size classes.
        // tell about background swap in and swap out threads and how synchronization should be performed.
        // explain what is the key in minimizing latency (keeping all the needed memory locally and moving it quickly) - like explained in the docs.
        // tell that only 3 out of 5 data shards are needed to minimize latency when restoring data.
        // tell about policies to evict and pre-fetch spans (and how those use stats collected, heuristics, FSM, ML models, including RNN). explain why grouping objects in spans is effective. explain why it is important to reduce fragmentation and how it can be
        // achieved. tell about compaction.
        // explain what typical performance numbers are in various environments.
        // tell about page placement algorithms
        // explain how different software accesses memory. Tell how "ideal" policy works. Tell why "least recently used" can be a bad policy in some cases.

        Block::SubsectionHeader(SubsectionHeaderBlock::without_numbering("Висновки до розділу".to_owned())),
        // general conclusions

        // in third section explain that a demo app was implemented to measure how well everything works and the hardware of the test environment.
    ])
}
