use crate::thesis::engine::{Block, subsection_header, paragraph};

pub fn reliability() -> Block {
    Block::Multiple(vec![
        subsection_header("Забезпечення відмовостійкості"),
        paragraph("Однією з проблем використання віддаленої памʼяті є те, що зберігання даних на інших пристроях має значний негативний вплив на розмір домену збою (failure domain). Тобто якщо \
зазвичай ключову роль у відмовостійкості програмного забезпечення грає деяка ймовірність що вузел обчислення вийде з ладу, то при використанні віддаленої памʼяті додається ймовірність що \
SSD диск (якщо він використовується як бекенд для зберігання даних) чи віддалений вузел (у випадку коли дані розміщуються на віддалених вузлах) вийде з ладу, що приведе до втрати частини даних. \
У випадку віддалених вузлів ризик збою стає значно високим, тому що з великою кількістю вузлів для втрати даних достатьно програмного чи апартного збою на будь-якому з них, тобто ризик втрати даних \
збільшується пропорційно."),
        paragraph("На жаль, не є можливим знизити ризик втрати даних при використанні віддаленої памʼяті до того ж самого рівня, як коли використовується тільки локальна оперативна памʼять. \
Але, можна мінімізувати ризик події коли дані будуть втрачені без можливості відновлення до такого рівня, який буде прийнятним для більшості сценаріїв використання на практиці."),
        paragraph("Найбільш простим методом забезпечення відмовостійкості є для кожного проміжку памʼяті (span) що було переміщено у памʼять віддаленого вузла, зберігати ще одну копію даних на \
локальному SSD диску. Недоліком цього підходу є високий рівень затримки у разі відмови вузла зберігання: читання даних з диску є набагато більш повільним ніж отримання даних по мережі, тому у разі \
відмови це негативно вплине на швидкодію програмного забезпечення, у яке інтегрована віддалена памʼять. Крім цього, це призводить до використання додаткового ресурсу - дискового простору, в результаті \
баланс між більш ефективним використанням оперативної памʼяті та додатковим використанням диску буде мати негативний вплив на розмір простору можливого застосування віддаленої памʼяті на практиці. \
Використання дискового простору можна зменшити використовуючи алогоритми стискання даних, такі як zstd, але це зробить систему більш повільною (найбільш швидкі алгоритми стискання даних обробляють \
на рівні сотень мегабайт у секунду) та збільшить використання ресурсів процесору, що не є бажаним при використанні віддаленої памʼяті. Оскільки можуть існувати середовища, де такий підхід є вигідним, \
то в реалізацію, яка розглядається в цій роботі, додано LocalDiskBackend який у поєднанні з ReplicationBackend (який забезпечує реплікацію на декілька бекендів) можна використовувати для реалізації \
цього підходу."),
        paragraph("Іншим методом є реплікація за фактором n, тобто збереження декількох (n) копій даних на різних вузлах зберігання. Цей підхід на відміну від попереднього забезпечує кращий рівень швидкодії \
у разі відновлення даних при відмові одного з вузлів. Недоліком цього методу є високий рівень використання ресурсів по кластеру: памʼяті використовується в n разів більше. В цій роботі цей метод забезпечення \
відмовостійкості реалізовано за допомогою ReplicationBackend, який може бути за конфігурацією користувача використаний разом з NetworkNodeBackend."),
        paragraph("Найбільш ефективним методом забезпечення відмовостійкості є кодування стиранням (erasure coding). У цій роботі розглядається кодування за допомогою коду Ріда-Соломона, який є поширеним \
методом виправленя помилок у блоках даних. Суть цього методу полягає в тому, що дані поділяються на N частин та M додаткових, які обчислюються через лінійне перетворення. При втраті будь-яких M частин \
дані можна відновити через зворотнє лінійне перетворення. N та M задаються користувачем, приклади зачень які можна взяти: (3, 2), (4, 3) та ін. - в залежності від середовища та вимог. Перевагою цього \
методу є швидке відновлення даних та відносно невелике використання додаткової памʼяті. В цій роботі це реалізовано у ErasureCodingBackend, який виконує кодування, а для власне зберігання даних передає \
шарди (частини) даних до існуючих реалізацій бекендів (наприклад NetworkNodeBackend)."),
        // tell about replication to remote nodes and local SSDs and erasure coding. Tell how exactly data will be restored and deleted. Explain that failure domain becomes larger when far memory is used.
        // tell about healthchecks.
    ])
}
